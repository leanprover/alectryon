<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />
<title>Literate programming with Alectryon (Lean4 input)</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Lean4 v4.0.0-nightly-2022-02-08. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+↑</kbd> <kbd>Ctrl+↓</kbd> to navigate, <kbd>Ctrl+🖱️</kbd> to focus. On Mac, use <kbd>⌘</kbd> instead of <kbd>Ctrl</kbd>.<br>Hover-Settings: Show types:<input id="toggleswitch" type="checkbox" onClick="toggleShowTypes(this);"> Show goals:<input id="toggleswitch" type="checkbox" onClick="toggleShowGoals(this);" checked><br></div><div class="document" id="literate-programming-with-alectryon-lean4-input">
<h1 class="title">Literate programming with Alectryon (Lean4 input)</h1>

<p>Alectryon supports literate programs and documents (combinations of code and prose) written in Lean4 and reStructuredText.  Here is an example written in Lean4.  It can be converted to reST, HTML, or LaTeX using the following commands:</p>
<pre class="literal-block">
alectryon literate_lean4.lean
    # Lean4+reST → HTML;  produces ‘literate_lean4.html’
alectryon literate_lean4.lean --backend latex \
     --latex-dialect xelatex \
     -o literate_lean4.xe.tex
    # Lean4+reST → LaTeX; produces ‘literate_lean4.xe.tex’
alectryon literate_lean4.lean --backend rst
    # Lean4+reST → reST;  produces ‘literate_lean4.lean.rst’
</pre>
<hr class="docutils" />
<div class="section" id="running-queries">
<h1>Running queries</h1>
<p>Alectryon captures the results of <code class="highlight lean4"><span class="k">#check</span></code>, <code class="highlight lean4"><span class="k">#eval</span></code>, and the like:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><div class="alectryon-token"><span class="kd">def</span></div><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>x</div><div class="alectryon-token"> : </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</div><div class="alectryon-token"> := </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></div><div class="alectryon-token">
</div><div class="alectryon-token"></div><div class="alectryon-token"></div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chk0"><div class="alectryon-token"><span class="k">#reduce</span></div><div class="alectryon-token"></div></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">10</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>5</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">5</span></div><div class="alectryon-token"> <span class="bp">+</span> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>x</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div>x</div><div class="alectryon-token"></div></span></pre><p>By default, these results are folded and are displayed upon hovering or clicking.  We can unfold them by default using annotations or directives:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="literate-lean4-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chk1"><div class="alectryon-token"><span class="k">#check</span></div><div class="alectryon-token"></div></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Nat : <span class="kt">Type</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Nat</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Nat</div><div class="alectryon-token"></div></span></pre><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="literate-lean4-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chk2"><div class="alectryon-token"><span class="k">#check</span></div><div class="alectryon-token"></div></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Bool : <span class="kt">Type</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Bool</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div>Bool</div><div class="alectryon-token">
</div><div class="alectryon-token"></div><div class="alectryon-token"></div></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="literate-lean4-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chk3"><div class="alectryon-token"><span class="k">#eval</span></div><div class="alectryon-token"></div></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="mi">2</span>
</blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></div><div class="alectryon-token"> <span class="bp">+</span> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>1</var><b>: </b><span>Nat</span></span></div></blockquote></div></small></div><span class="mi">1</span></div><div class="alectryon-token"></div></span></pre><p>Other flags can be used to control display, like <tt class="docutils literal"><span class="pre">.no-in</span></tt>:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="literate-lean4-lean-chk4" style="display: none" type="checkbox"><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kd">inductive</span> Iff : <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span>
constructors:
Iff.intro : <span class="bp">∀</span> {a b : <span class="kt">Prop</span>}, (a <span class="bp">→</span> b) <span class="bp">→</span> (b <span class="bp">→</span> a) <span class="bp">→</span> (a <span class="bp">↔</span> b)
</blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Iff</var><b>: </b><span>Prop → Prop → Prop</span></span></div></blockquote></div></small></div>Iff</div><div class="alectryon-token"></div></span></pre></div>
<div class="section" id="documenting-proofs">
<h1>Documenting proofs</h1>
<p>Alectryon also captures goals and hypotheses as proofs progress:</p>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><div class="alectryon-token"><span class="kd">theorem</span></div><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>test</var><b>: </b><span>∀ (p q : Prop), p → q → (p ∧ q ↔ q ∧ p)</span></span></div></blockquote></div></small></div>test</div><div class="alectryon-token"> (</div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></div><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>q</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">q</span></div><div class="alectryon-token"> : </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Prop</var><b>: </b><span>Type</span></span></div></blockquote></div></small></div><span class="kt">Prop</span></div><div class="alectryon-token">) (</div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hp</var><b>: </b><span>p</span></span></div></blockquote></div></small></div><span class="nv">hp</span></div><div class="alectryon-token"> : </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></div><div class="alectryon-token">) (</div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hq</var><b>: </b><span>q</span></span></div></blockquote></div></small></div><span class="nv">hq</span></div><div class="alectryon-token"> : </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>q</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">q</span></div><div class="alectryon-token">): </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></div><div class="alectryon-token"> <span class="bp">∧</span> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>q</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">q</span></div><div class="alectryon-token"> <span class="bp">↔</span> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>q</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">q</span></div><div class="alectryon-token"> <span class="bp">∧</span> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>p</var><b>: </b><span>Prop</span></span></div></blockquote></div></small></div><span class="nv">p</span></div><div class="alectryon-token"> := </div><div class="alectryon-token"><span class="kd">by</span></div><div class="alectryon-token">
  </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">`apply e` tries to match the current goal against the conclusion of `e`'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.
</blockquote></div></small></div></div><div class="alectryon-token"></div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chk5"><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">`apply e` tries to match the current goal against the conclusion of `e`'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.
</blockquote></div></small></div><span class="k">apply</span></div><div class="alectryon-token"></div><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>Iff.intro</var><b>: </b><span>∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)</span></span></div></blockquote></div></small></div><span class="k">Iff.intro</span></div><div class="alectryon-token"></div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mp</span></span><div class="goal-conclusion">p <span class="bp">∧</span> q <span class="bp">→</span> q <span class="bp">∧</span> p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="literate-lean4-lean-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br></div><label class="goal-separator" for="literate-lean4-lean-chk6"><hr><span class="goal-name">mpr</span></label><div class="goal-conclusion">q <span class="bp">∧</span> p <span class="bp">→</span> p <span class="bp">∧</span> q</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
  </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chk7"><div class="alectryon-token"><span class="bp">.</span></div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mp</span></span><div class="goal-conclusion">p <span class="bp">∧</span> q <span class="bp">→</span> q <span class="bp">∧</span> p</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">Introduce one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.
* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,
  or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
</blockquote></div></small></div></div><div class="alectryon-token"></div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chk8"><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">Introduce one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.
* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,
  or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
</blockquote></div></small></div><span class="k">intro</span></div><div class="alectryon-token"></div><div class="alectryon-token"> h</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p <span class="bp">∧</span> q</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mp</span></span><div class="goal-conclusion">q <span class="bp">∧</span> p</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
    </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">`apply e` tries to match the current goal against the conclusion of `e`'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.
</blockquote></div></small></div></div><div class="alectryon-token"></div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chk9"><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">`apply e` tries to match the current goal against the conclusion of `e`'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.
</blockquote></div></small></div><span class="k">apply</span></div><div class="alectryon-token"></div><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>And.intro</var><b>: </b><span>∀ {a b : Prop}, a → b → a ∧ b</span></span></div></blockquote></div></small></div><span class="k">And.intro</span></div><div class="alectryon-token"></div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p <span class="bp">∧</span> q</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mp.left</span></span><div class="goal-conclusion">q</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="literate-lean4-lean-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p <span class="bp">∧</span> q</span></span></span><br></div><label class="goal-separator" for="literate-lean4-lean-chka"><hr><span class="goal-name">mp.right</span></label><div class="goal-conclusion">p</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
    </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chkb"><div class="alectryon-token"><span class="bp">.</span></div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p <span class="bp">∧</span> q</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mp.left</span></span><div class="goal-conclusion">q</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">`exact e` closes the main goal if its target type matches that of `e`.
</blockquote></div></small></div><span class="k">exact</span></div><div class="alectryon-token"></div><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hq</var><b>: </b><span>q</span></span></div></blockquote></div></small></div><span class="nv">hq</span></div><div class="alectryon-token">
    </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chkc"><div class="alectryon-token"><span class="bp">.</span></div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>p <span class="bp">∧</span> q</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mp.right</span></span><div class="goal-conclusion">p</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">`exact e` closes the main goal if its target type matches that of `e`.
</blockquote></div></small></div><span class="k">exact</span></div><div class="alectryon-token"></div><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hp</var><b>: </b><span>p</span></span></div></blockquote></div></small></div><span class="nv">hp</span></div><div class="alectryon-token">
  </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chkd"><div class="alectryon-token"><span class="bp">.</span></div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mpr</span></span><div class="goal-conclusion">q <span class="bp">∧</span> p <span class="bp">→</span> p <span class="bp">∧</span> q</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">Introduce one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.
* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,
  or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
</blockquote></div></small></div></div><div class="alectryon-token"></div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chke"><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">Introduce one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.
* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,
  or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
</blockquote></div></small></div><span class="k">intro</span></div><div class="alectryon-token"></div><div class="alectryon-token"> h</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>q <span class="bp">∧</span> p</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mpr</span></span><div class="goal-conclusion">p <span class="bp">∧</span> q</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
    </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">`apply e` tries to match the current goal against the conclusion of `e`'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.
</blockquote></div></small></div></div><div class="alectryon-token"></div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chkf"><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">`apply e` tries to match the current goal against the conclusion of `e`'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.
</blockquote></div></small></div><span class="k">apply</span></div><div class="alectryon-token"></div><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>And.intro</var><b>: </b><span>∀ {a b : Prop}, a → b → a ∧ b</span></span></div></blockquote></div></small></div><span class="k">And.intro</span></div><div class="alectryon-token"></div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>q <span class="bp">∧</span> p</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mpr.left</span></span><div class="goal-conclusion">p</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="literate-lean4-lean-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>q <span class="bp">∧</span> p</span></span></span><br></div><label class="goal-separator" for="literate-lean4-lean-chk10"><hr><span class="goal-name">mpr.right</span></label><div class="goal-conclusion">q</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
    </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chk11"><div class="alectryon-token"><span class="bp">.</span></div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>q <span class="bp">∧</span> p</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mpr.left</span></span><div class="goal-conclusion">p</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">`exact e` closes the main goal if its target type matches that of `e`.
</blockquote></div></small></div><span class="k">exact</span></div><div class="alectryon-token"></div><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hp</var><b>: </b><span>p</span></span></div></blockquote></div></small></div><span class="nv">hp</span></div><div class="alectryon-token">
    </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="literate-lean4-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="literate-lean4-lean-chk12"><div class="alectryon-token"><span class="bp">.</span></div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, q</var><span class="hyp-type"><b>: </b><span><span class="kt">Prop</span></span></span></span><br><span><var>hp</var><span class="hyp-type"><b>: </b><span>p</span></span></span><br><span><var>hq</var><span class="hyp-type"><b>: </b><span>q</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>q <span class="bp">∧</span> p</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">mpr.right</span></span><div class="goal-conclusion">q</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper full-width"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal alectryon-docstring">`exact e` closes the main goal if its target type matches that of `e`.
</blockquote></div></small></div><span class="k">exact</span></div><div class="alectryon-token"></div><div class="alectryon-token"> </div><div class="alectryon-token"><div class="alectryon-type-info-wrapper"><small class="alectryon-type-info"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span class="hyp-type"><var>hq</var><b>: </b><span>q</span></span></div></blockquote></div></small></div><span class="nv">hq</span></div><div class="alectryon-token"></div></span></pre></div>
</div>
</div></body>
</html>
